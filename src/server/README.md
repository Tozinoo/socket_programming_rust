# Rust 비동기 I/O 서버 이벤트 루프 흐름

이 문서는 Rust와 `mio`를 사용한 비동기 I/O 서버의 이벤트 루프 흐름을 설명합니다. 이 서버는 클라이언트 연결, 데이터 읽기/쓰기 등을 처리하며 논블로킹 방식으로 동작합니다.

---

## 이벤트 루프 다이어그램

```plaintext
+-----------------------+
|    Start Event Loop   |
+-----------------------+
           |
           v
+-----------------------+
| poll.poll()           |
| (Wait for Events)     |
+-----------------------+
           |
           v
+-----------------------+
| Handle Events         |
| - New Connections     |
| - Readable/Writable   |
+-----------------------+
           |
           v
+-----------------------+
| Update Client States  |
| - Add New Clients     |
| - Remove Disconnected |
+-----------------------+
           |
           v
+-----------------------+
| Loop Back             |
+-----------------------+
```

---

### 1. 이벤트 루프 시작
- 서버가 실행되면서 이벤트 루프가 시작됩니다.
- 서버는 네트워크 소켓에서 발생하는 다양한 이벤트(새 연결, 데이터 읽기/쓰기)를 감지하고 처리합니다.

---

### 2. `poll.poll()` 호출
- 소켓에 등록된 이벤트가 발생할 때까지 대기합니다.
- 예를 들어:
  - 클라이언트가 연결 요청을 보냄.
  - 클라이언트가 데이터를 보냄.
  - 클라이언트로 데이터를 보낼 준비가 됨.
- 이 단계는 **블로킹** 또는 **타임아웃** 설정에 따라 대기 시간을 조정할 수 있습니다.

---

### 3. 이벤트 처리
- `poll.poll()`이 반환한 이벤트를 하나씩 처리합니다:
  - **새로운 연결**: 클라이언트가 서버에 연결을 요청하면 이를 수락(`accept`)하고 등록합니다.
  - **읽기 가능 상태**: 클라이언트가 보낸 데이터를 읽어 처리합니다.
  - **쓰기 가능 상태**: 서버가 클라이언트로 데이터를 전송합니다.

---

### 4. 클라이언트 상태 갱신
- 서버는 연결된 클라이언트의 상태를 관리합니다:
  - **새 클라이언트 추가**: 연결된 클라이언트를 이벤트 루프에 등록합니다.
  - **연결 종료 클라이언트 제거**: 더 이상 활성 상태가 아닌 클라이언트를 제거하여 자원을 정리합니다.

---

### 5. 루프 재시작
- 이벤트를 처리한 뒤, 다시 `poll.poll()`로 돌아가 새로운 이벤트를 기다립니다.
- 이 과정은 서버가 종료될 때까지 계속 반복됩니다.
